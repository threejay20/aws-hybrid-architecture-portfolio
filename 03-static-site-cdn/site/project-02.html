<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Project 02 — Event-Driven Architecture</title>
  <link rel="stylesheet" href="styles.css" />
</head>
<body>
  <div class="container">
    <header class="topbar">
      <div class="brand">
        <div class="logo" aria-hidden="true"></div>
        <div>
          <h1>Project 02 — Event-Driven Architecture</h1>
          <div class="sub">SNS • SQS • Lambda • Dead Letter Queue</div>
        </div>
      </div>
      <nav class="nav">
        <a href="index.html">Home</a>
        <a href="project-01.html">Project 01</a>
        <a class="active" href="project-02.html">Project 02</a>
      </nav>
    </header>

    <section class="hero">
      <h2>Architecture rationale</h2>
      <p>
        This system uses asynchronous messaging to decouple producers from consumers
        and to handle failure without data loss. Events are published to an SNS topic,
        buffered by SQS, and processed by Lambda. Repeated failures are routed to a
        Dead Letter Queue for inspection and recovery.
      </p>
    </section>

    <div class="grid">
      <section class="card half">
        <h3>Architecture</h3>
        <p><strong>Producer → SNS → SQS → Lambda</strong> (with DLQ for failures)</p>
        <div class="kv">
          <div class="key">Decoupling</div>
          <div class="val">Producers are isolated from consumer throughput and failure modes</div>

          <div class="key">Reliability</div>
          <div class="val">Messages are retried automatically and preserved on repeated failure</div>

          <div class="key">Scaling model</div>
          <div class="val">Lambda concurrency scales based on queue depth</div>
        </div>
      </section>

      <section class="card half">
        <h3>Design considerations</h3>
        <p>
          The architecture prioritizes durability and operational simplicity over strict ordering.
          At-least-once delivery is acceptable, and duplicate processing is handled at the consumer.
        </p>
        <div class="kv">
          <div class="key">Fanout</div>
          <div class="val">SNS enables multiple independent consumers per event</div>

          <div class="key">Buffering</div>
          <div class="val">SQS absorbs traffic spikes and protects downstream services</div>

          <div class="key">Failure isolation</div>
          <div class="val">Poison-pill messages are isolated via a DLQ</div>
        </div>
      </section>

      <section class="card">
        <h3>Failure handling</h3>
        <p>
          Message processing failures result in the message being returned to the queue
          after the visibility timeout. After exceeding the configured receive count,
          the message is moved to the Dead Letter Queue.
        </p>

        <div class="code">
Failure behavior:
- At-least-once delivery semantics
- Visibility timeout controls retry timing
- maxReceiveCount determines DLQ routing
        </div>

        <div class="section-title">Operational workflow</div>
        <div class="kv">
          <div class="key">Processing errors</div>
          <div class="val">Investigated via CloudWatch Logs</div>

          <div class="key">Queue backlog</div>
          <div class="val">Evaluated using message age and Lambda concurrency</div>

          <div class="key">DLQ growth</div>
          <div class="val">Messages inspected, corrected, and optionally redriven</div>
        </div>
      </section>
    </div>

    <footer class="footer">
      Failure is an expected condition. Retries and DLQ routing are deliberate design choices to preserve durability and system stability.
    </footer>
  </div>
</body>
</html>

